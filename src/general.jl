export
    # model and common random numbers
    simulate_data, common_random, common_random!,
    # likelihood
    MLE, loglikelihood, indirect_logposterior,
    # modeling API
    IndirectLikelihoodProblem, simulate_problem, loglikelihood, local_jacobian,
    vec_parameters


# structural model and common random numbers

"""
    $SIGNATURES

Simulate data from the `model`

1. using random number generator `rng`,

2. with parameters `θ`,

2. common random numbers `ϵ`.

This method should

1. accept `ϵ` generated by [`common_random`](@ref),

2. return simulated `data` in the format that can be used by [`MLE`](@ref) and
[`loglikelihood`](@ref).

!!! usage

    The user should define a method for this function for each `model` type with
    the signature

    ```julia
    simulate_data(rng::AbstractRNG, model, θ, ϵ)
    ```

    For infeasible/meaningless parameters, return `nothing`.
"""
simulate_data(rng::AbstractRNG, model, θ, ϵ) =
    no_model_method(simulate_data, rng, model, θ, ϵ)

"""
    $SIGNATURES

Simulate data, generating `ϵ` using `rng`.

See [`common_random`](@ref).

!!! usage

    For interactive/exploratory use. Models should define methods for
    [`simulate_data(rng::AbstractRNG, model, θ, ϵ)`](@ref).
"""
simulate_data(rng::AbstractRNG, model, θ) =
    simulate_data(rng, model, θ, common_random(rng, model))

"""
   $SIGNATURES

Simulate data, generating `ϵ` with the default random number generator.

See [`common_random`](@ref).

!!! usage

    For interactive/exploratory use. Models should define methods for
    [`simulate_data(rng::AbstractRNG, model, θ, ϵ)`](@ref).
"""
simulate_data(model, θ) = simulate_data(RNG, model, θ)

"""
    $SIGNATURES

Return common random numbers that can be reused by [`simulate_data`](@ref) with
different parameters.

When the model structure does not allow common random numbers, the convention is
to return `nothing`.

The first argument is the random number generator.

!!! usage

    The user should define a method for this function for each `model` type.

See also [`common_random!`](@ref) for further optimizations.
"""
common_random(rng::AbstractRNG, model) =
    no_model_method(common_random, rng, model)

"""
    $SIGNATURES

Update the common random numbers for the model. The semantics is as follows:

1. it *can*, but does not need to, change the contents of its argument `ϵ`,

2. the “new” common random numbers should be *returned* regardless.

Two common usage patterns are

1. having a mutable `ϵ`, updating that in place, returning `ϵ`,

2. generating new `ϵ`, returning that.

!!! note

    The default method falls back to [`common_random`](@ref), reallocating with
    each call. A method for this function should be defined only when
    allocations can be optimized.
"""
common_random!(rng, model, ϵ) = common_random(rng, model)


# problem interface

struct IndirectLikelihoodProblem{M, P, D, R <: AbstractRNG, E}
    """
    The model, used by [`simulate_data`](@ref), [`common_random`](@ref),
    [`MLE`](@ref), and [`loglikelihood`](@ref).
    """
    model::M
    """
    A callable which accepts the same parameters `θ` as arguments as
    [`simulate_data`](@ref), and returns the **log** of the prior density for
    those parameters (can be `-Inf`, otherwise needs to be finite).
    """
    logprior::P
    """
    The data
    """
    data::D
    """
    Random number generator used by [`simulate_data`](@ref) and
    [`common_random`](@ref).
    """
    rng::R
    """
    Saved values for common random numbers. [`common_random!`] can be used to
    update.
    """
    ϵ::E
end

"""
    $SIGNATURES

A simple wrapper for an indirect likelihood problem, with the given `model`
object, log prior, and data.

The random number generator `rng` is saved, and used to initialize the common
random numbers `ϵ` by default.

The user should implement [`simulate_data`](@ref), [`MLE`](@ref),
[`loglikelihood`](@ref), and [`common_random`](@ref).
"""
IndirectLikelihoodProblem(model, logprior, data;
                          rng::AbstractRNG = RNG, ϵ = common_random(rng, model)) =
    IndirectLikelihoodProblem(model, logprior, data, rng, ϵ)


"""
    $SIGNATURES

Return a new problem with updated common random numbers.
"""
function common_random!(problem::IndirectLikelihoodProblem)
    @unpack model, logprior, data, rng, ϵ = problem
    ϵ′ = common_random!(rng, model, ϵ)
    IndirectLikelihoodProblem(model, logprior, data, rng, ϵ′)
end

"""
    $SIGNATURES

Simulate data with the given parameters `θ`.
"""
function simulate_data(problem::IndirectLikelihoodProblem, θ)
    @unpack rng, model, ϵ = problem
    simulate_data(rng, model, θ, ϵ)
end

"""
    $SIGNATURES

Initialize an [`IndirectLikelihoodProblem`](@ref) with simulated data, using
parameters `θ`.

Useful for debugging and exploration of identification with simulated data.
"""
function simulate_problem(model, logprior, θ;
                          rng = RNG, ϵ = common_random(rng, model))
    data = simulate_data(rng, model, θ, ϵ)
    IndirectLikelihoodProblem(model, logprior, data, rng, ϵ)
end


# likelihood

"""
    $SIGNATURES

Maximum likelihood estimate of the parameters for `data` in `model`.

When `ϕ == MLE(model, data)`, `ϕ` should maximize

```julia
ϕ -> loglikelihood(model, data, ϕ)
```

See [`loglikelihood`](@ref).

Methods should be defined by the user for each `model` type.
"""
MLE(model, data) = no_model_method(MLE, model, data)

"""
    $SIGNATURES

Log likelihood of `data` under `model` with parameters ``ϕ``. See [`MLE`](@ref).
"""
loglikelihood(model, data, ϕ) = no_model_method(loglikelihood, model, data, ϕ)


# problem framework

"""
    $SIGNATURES

Return an estimate of the auxiliary parameters `ϕ` as a function of the
structural parameters `θ`.

This is also known the *mapping* or *binding function* in the indirect inference
literature.
"""
function indirect_estimate(problem::IndirectLikelihoodProblem, θ)
    data = simulate_data(problem, θ)
    data == nothing ? nothing : MLE(problem.model, data)
end

"""
    $SIGNATURES

Evaluate the indirect log posterior of `problem` at parameters `θ`.

Short-circuits for infeasible parameters.
"""
function indirect_logposterior(problem::IndirectLikelihoodProblem, θ)
    @unpack data, logprior, model = problem
    ϕ = indirect_estimate(problem, θ)
    ϕ == nothing ? -Inf : loglikelihood(model, data, ϕ) + logprior(θ)
end

"""
    $SIGNATURES

Return a callable that evaluates `indirect_logposterior(problem, θ)` at the
given `θ`.
"""
indirect_logposterior(problem::IndirectLikelihoodProblem) =
    θ -> indirect_logposterior(problem, θ)


# local analysis

"""
    $SIGNATURES

Return the values of the argument as a vector, potentially (but not necessarily)
restricting to those elements that uniquely determine the argument.

For example, a symmetric matrix would be determined by the diagonal and either
half.
"""
function vec_parameters end

vec_parameters(x::Real) = [x]

vec_parameters(xs::Tuple) = vcat(map(vec_parameters, xs)...)

vec_parameters(A::AbstractArray) = vec(A)

"""
    $SIGNATURES

Flattened elements from the upper triangle. Helper function for
[`vec_parameters`](@ref).
"""
function vec_upper(U::AbstractMatrix{T}) where T
    n = LinAlg.checksquare(U)
    l = n*(n+1) ÷ 2
    v = Vector{T}(l)
    k = 1
    @inbounds for i in 1:n
        for j in 1:i
            v[k] = U[j, i]
            k += 1
        end
    end
    v
end

"""
    $SIGNATURES

Flattened elements from the lower triangle. Helper function for
[`vec_parameters`](@ref).
"""
function vec_lower(L::AbstractMatrix{T}) where T
    n = LinAlg.checksquare(L)
    l = n*(n+1) ÷ 2
    v = Vector{T}(l)
    k = 1
    @inbounds for i in 1:n
        for j in i:n
            v[k] = L[j, i]
            k += 1
        end
    end
    v
end

vec_parameters(A::Union{Symmetric, UpperTriangular}) = vec_upper(A)

vec_parameters(A::LowerTriangular) = vec_lower(A)

"""
    $SIGNATURES

Calculate the local Jacobian of the estimated auxiliary parameters ``ϕ`` at the
structural parameters ``θ=θ₀``.

`ω_to_θ` is a transformation that maps a vector of reals ``ω ∈ ℝⁿ`` to the
parameters `θ` in the format acceptable to [`simulate_data`](@ref). It should
support [`ContinuousTransformations.transform`](@ref) and
[`ContinuousTransformations.inverse`](@ref). See, for example,
[`ContinuousTransformations.TransformationTuple`](@ref).

`vecϕ` is a function that is used to flatten the auxiliary parameters to a
vector. Defaults to [`vec_parameters`](@ref).
"""
function local_jacobian(problem::IndirectLikelihoodProblem, θ₀, ω_to_θ;
                        vecϕ = vec_parameters)
    ω₀ = inverse(ω_to_θ, θ₀)
    jacobian(ω₀) do ω
        θ = transform(ω_to_θ, ω)
        ϕ = indirect_estimate(problem, θ)
        vecϕ(ϕ)
    end
end
